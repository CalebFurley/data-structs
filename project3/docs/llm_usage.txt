Prompt:
  Im doing a project for school,
  class CPUJob { 
  public:     
    int job_id;               // Unique identifier for the job     
    int priority;             // Priority level of the job (1-10)     
    int job_type;             // Job type (1-10)     
    int cpu_time_consumed;    // Total CPU time consumed by the job  
    int memory_consumed;      // Total memory consumed thus far 

    CPUJob(int job_id, int priority, int job_type,
            int cpu_time_consumed, int memory_consumed);
    ~CPUJob();
    void display();
  }; 

  template <class DT> class Queue { 
  public:     
    DT* JobPointer;           // Pointer to a job (e.g., CPUJob)     
    Queue<DT>* next;          // Pointer to the next node in the queue 
  };  

  template <class DT> class NovelQueue { 
  public:   
    Queue<DT>* front;         // Pointer to the front of the queue   
    Queue<DT>** NodePtrs;     // Array of pointers to Queue nodes     
    int size;                 // Number of elements in the queue) 

    void enqueue(CPUJob* newJob);
    CPUJob* dequeue();
    void modify(int job_id, int new_priority, int new_job_type, 
                  int new_cpu_time_consumed, int new_memory_consumed);  
    void change(int job_id, int field_index, int new_value);     
    void promote(int job_id, int positions);
    NovelQueue<DT>* reorder(int attribute_index); 
    void display();
    int count();
    void listJobs();
  }; 
  why would there be a queue class and a novel queue class?

Response:
  The presence of both [`Queue`]() and [`NovelQueue`]()
  1. **Queue Class**:
    - **Purpose**: Represents a single node in a queue.
    - **Attributes**:
      - [`JobPointer`](): Points to a job ()
      - [`next`](): Points to the next node in the queue.
    - **Usage**: Acts as a linked list node, holding a job and a reference to the next node.

  2. **NovelQueue Class**:
    - **Purpose**: Represents the entire queue and provides advanced queue operations.
    - **Attributes**:
      - [`front`](): Points to the front node of the queue.
      - [`NodePtrs`](): An array of pointers to [`Queue`]() nodes, possibly for quick access or indexing.
      - [`size`](): Keeps track of the number of elements in the queue.
    - **Methods**:
      - [`enqueue`](): Adds a new job to the queue.
      - [`dequeue`](): Removes and returns a job from the front of the queue.
      - [`modify`](): Modifies attributes of a job based on its ID.
      - [`change`](): Changes a specific field of a job.
      - [`promote`](): Promotes a job by a certain number of positions.
      - [`reorder`](): Reorders the queue based on a specific attribute.
      - [`display`](): Displays the queue.
      - [`count`](): Returns the number of jobs in the queue.
      - [`listJobs`](): Lists all jobs in the queue.

  ### Summary
  - **Queue**: Basic node structure for linked list implementation.
  - **NovelQueue**: Advanced queue with additional functionalities and operations.

  This design allows for modularity and separation of concerns, where () provides higher-level queue management and operations.

Reason:
  Double check my thoughts on why the queue class and novel queue class both exist (was thinking queue is for nodes), and also to
  see if the chatbot could give any other starting insight into the use of these classes. It did, in the fact that it pointed out
  that the array of queue pointers within novel queue can be used for constant time retrieval of jobs instead of o(n) if we had
  to traverse the linkedlist every time. With this knowledge I should be able to get started on the project.
------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    delete _front;
    delete _rear;
    for (Queue<DT> node : _NodePtrs) { //delete all nodes
      delete node;
      node = nullptr;
    } 
    delete _NodePtrs; //delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }

  does this methodology look good?

Response:
  There are a few issues with the destructor implementation:

1. **Deleting [`_front`]() directly**: If [`_front`]() is incorrect. It should be a pointer to a pointer.
3. **Deleting [`_NodePtrs`]()**: [`_NodePtrs`]() is an array of pointers, so it should be deleted using `delete[]`.

Here's a revised version:

  ```cpp
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    // Delete all nodes in the linked list
    Queue<DT>* current = _front;
    while (current != nullptr) {
      Queue<DT>* next = current->next;
      delete current;
      current = next;
    }

    // Delete the array of node pointers
    if (_NodePtrs != nullptr) {
      for (int i = 0; i < size; ++i) {
        delete _NodePtrs[i];
        _NodePtrs[i] = nullptr;
      }
      delete[] _NodePtrs;
      _NodePtrs = nullptr;
    }

    _front = nullptr;
    _rear = nullptr;
  }
  ```

  ### Changes Made:
  1. **Iterate through the linked list**: Properly delete all nodes in the linked list starting from [`_front`]().
  2. **Correct iteration over [`_NodePtrs`]().
  3. **Use `delete[]` for [`_NodePtrs`]() is an array, use `delete[]` to delete it.

  This ensures that all dynamically allocated memory is properly freed.

Reason:
  Wanted to check the destructor and make sure the smaller functions needed 
  are implemented correctly and quickly so I can move onto the NoveQueue and
  main() and get working on the main portion of the project.
------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    Queue<DT>* current = _front;
    while (current != nullptr) { //delete all the nodes
      Queue<DT>* tempNext = current->_next;
      delete current;
      current = tempNext;
    }
    delete[] _NodePtrs; //delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }


  double checking, this look good>
Response:
  The destructor implementation looks good overall. It correctly deletes all nodes in the linked list and then deletes the array of node pointers. Here is a quick review and confirmation:

  1. **Deleting Nodes**: The loop correctly iterates through the linked list, deleting each node.
  2. **Deleting Node Pointers Array**: The `delete[] _NodePtrs` statement correctly deletes the array of node pointers.
  3. **Nullifying Pointers**: Setting [`_front`](), [`_rear`](), and [`_NodePtrs`]() to [`nullptr`]() ensures that the pointers are nullified after deletion.

  Here is the code again for confirmation:

  ```cpp
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    Queue<DT>* current = _front;
    while (current != nullptr) { // delete all the nodes
      Queue<DT>* tempNext = current->_next;
      delete current;
      current = tempNext;
    }
    delete[] _NodePtrs; // delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }
  ```

  ### Summary
  - **Loop through the linked list**: Correctly deletes each node.
  - **Delete the array of node pointers**: Correctly deletes the array.
  - **Nullify pointers**: Ensures pointers are set to [`nullptr`]() after deletion.

  This destructor implementation is correct and should work as intended.

Reason:
  Double checking the way I implemented what was suggested in the previous copilot
  suggesstion.

------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::NovelQueue() {
    //implement this..
  }


  what size should set _NodePtrs too inside this constructor?
Response:
  The size of `_NodePtrs` should be initialized to a reasonable default value, typically zero, since the queue is initially empty. You can dynamically allocate the array as needed when elements are added to the queue.

  Here's the implementation of the constructor:

  ```cpp
  template <class DT>
  NovelQueue<DT>::NovelQueue() : _front(nullptr), _rear(nullptr), _NodePtrs(nullptr), size(0) {
    // Initially, the queue is empty, so _NodePtrs is set to nullptr and size is set to 0.
  }
  ```

  ### Explanation:
  - **`_front` and `_rear`**: Initialized to `nullptr` because the queue is empty.
  - **`_NodePtrs`**: Initialized to `nullptr` because there are no nodes in the queue initially.
  - **`size`**: Initialized to `0` because the queue is empty.

  This ensures that the queue starts in a consistent and empty state. As elements are added to the queue, `_NodePtrs` can be dynamically allocated and resized accordingly.

Reason:
  Trying to figure out best size to allocate the _NodePtrs* array too. Personally
  I figured I would need another constructor with a size (size being the number)
  of commands passed (even though some commands will end before others start)
  but this makes sure that the program doesnt run out of space in the job Queue
  duing runtime. (if the nodepointers array wasnt needed this could be done 
  dynamically much easier, I dont want to need to change the array size throughout
  the program so I'm just going to make another constructor that is the size of the
  number of commands and call it good.)
------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::NovelQueue(int size) {
    _NodePtrs = new Queue<DT>(n)
  }
  is this correct to make an array of queue pointers of size n
Response:
  The provided code snippet has a few issues:
  1. The parameter name should be [`size`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A110%2C%22character%22%3A31%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition") instead of [`n`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A111%2C%22character%22%3A28%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition").
  2. The syntax for creating an array of pointers is incorrect.
  3. The constructor should initialize `_front` and `_rear` to `nullptr`.

  Here is the corrected version:

  ```cpp
  template <class DT>
  NovelQueue<DT>::NovelQueue(int size) : _front(nullptr), _rear(nullptr), size(size) {
    _NodePtrs = new Queue<DT>*[size];
    for (int i = 0; i < size; ++i) {
      _NodePtrs[i] = nullptr;
    }
  }
  ```

  ### Explanation:
  - **Initialization List**: Initializes `_front`, `_rear`, and [`size`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A110%2C%22character%22%3A31%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition").
  - **Array Allocation**: Allocates an array of [`Queue<DT>*`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A111%2C%22character%22%3A18%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition") of the given [`size`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A110%2C%22character%22%3A31%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition").
  - **Null Initialization**: Initializes each element of [`_NodePtrs`](command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fcaleb%2FDevelopment%2Fsource%2Fdata-structs%2Fproject3%2Fproject3.cpp%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A111%2C%22character%22%3A2%7D%7D%5D%2C%229649689a-12c5-4205-ace3-7b95367ba2f9%22%5D "Go to definition") to `nullptr`.

Reason:
  Making sure the method is correct, it suggested to loop through and set all
  the pointers to null so thats what I will do.
------------------------------------------------------------------------------

Prompt:

Response:

Reason:

------------------------------------------------------------------------------

Prompt:

Response:

Reason:

------------------------------------------------------------------------------