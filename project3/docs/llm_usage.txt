Prompt:
  Im doing a project for school,
  class CPUJob { 
  public:     
    int job_id;               // Unique identifier for the job     
    int priority;             // Priority level of the job (1-10)     
    int job_type;             // Job type (1-10)     
    int cpu_time_consumed;    // Total CPU time consumed by the job  
    int memory_consumed;      // Total memory consumed thus far 

    CPUJob(int job_id, int priority, int job_type,
            int cpu_time_consumed, int memory_consumed);
    ~CPUJob();
    void display();
  }; 

  template <class DT> class Queue { 
  public:     
    DT* JobPointer;           // Pointer to a job (e.g., CPUJob)     
    Queue<DT>* next;          // Pointer to the next node in the queue 
  };  

  template <class DT> class NovelQueue { 
  public:   
    Queue<DT>* front;         // Pointer to the front of the queue   
    Queue<DT>** NodePtrs;     // Array of pointers to Queue nodes     
    int size;                 // Number of elements in the queue) 

    void enqueue(CPUJob* newJob);
    CPUJob* dequeue();
    void modify(int job_id, int new_priority, int new_job_type, 
                  int new_cpu_time_consumed, int new_memory_consumed);  
    void change(int job_id, int field_index, int new_value);     
    void promote(int job_id, int positions);
    NovelQueue<DT>* reorder(int attribute_index); 
    void display();
    int count();
    void listJobs();
  }; 
  why would there be a queue class and a novel queue class?

Response:
  The presence of both [`Queue`]() and [`NovelQueue`]()
  1. **Queue Class**:
    - **Purpose**: Represents a single node in a queue.
    - **Attributes**:
      - [`JobPointer`](): Points to a job ()
      - [`next`](): Points to the next node in the queue.
    - **Usage**: Acts as a linked list node, holding a job and a reference to the next node.

  2. **NovelQueue Class**:
    - **Purpose**: Represents the entire queue and provides advanced queue operations.
    - **Attributes**:
      - [`front`](): Points to the front node of the queue.
      - [`NodePtrs`](): An array of pointers to [`Queue`]() nodes, possibly for quick access or indexing.
      - [`size`](): Keeps track of the number of elements in the queue.
    - **Methods**:
      - [`enqueue`](): Adds a new job to the queue.
      - [`dequeue`](): Removes and returns a job from the front of the queue.
      - [`modify`](): Modifies attributes of a job based on its ID.
      - [`change`](): Changes a specific field of a job.
      - [`promote`](): Promotes a job by a certain number of positions.
      - [`reorder`](): Reorders the queue based on a specific attribute.
      - [`display`](): Displays the queue.
      - [`count`](): Returns the number of jobs in the queue.
      - [`listJobs`](): Lists all jobs in the queue.

  ### Summary
  - **Queue**: Basic node structure for linked list implementation.
  - **NovelQueue**: Advanced queue with additional functionalities and operations.

  This design allows for modularity and separation of concerns, where () provides higher-level queue management and operations.

Reason:
  Double check my thoughts on why the queue class and novel queue class both exist (was thinking queue is for nodes), and also to
  see if the chatbot could give any other starting insight into the use of these classes. It did, in the fact that it pointed out
  that the array of queue pointers within novel queue can be used for constant time retrieval of jobs instead of o(n) if we had
  to traverse the linkedlist every time. With this knowledge I should be able to get started on the project.
------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    delete _front;
    delete _rear;
    for (Queue<DT> node : _NodePtrs) { //delete all nodes
      delete node;
      node = nullptr;
    } 
    delete _NodePtrs; //delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }

  does this methodology look good?

Response:
  There are a few issues with the destructor implementation:

1. **Deleting [`_front`]() directly**: If [`_front`]() is incorrect. It should be a pointer to a pointer.
3. **Deleting [`_NodePtrs`]()**: [`_NodePtrs`]() is an array of pointers, so it should be deleted using `delete[]`.

Here's a revised version:

  ```cpp
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    // Delete all nodes in the linked list
    Queue<DT>* current = _front;
    while (current != nullptr) {
      Queue<DT>* next = current->next;
      delete current;
      current = next;
    }

    // Delete the array of node pointers
    if (_NodePtrs != nullptr) {
      for (int i = 0; i < size; ++i) {
        delete _NodePtrs[i];
        _NodePtrs[i] = nullptr;
      }
      delete[] _NodePtrs;
      _NodePtrs = nullptr;
    }

    _front = nullptr;
    _rear = nullptr;
  }
  ```

  ### Changes Made:
  1. **Iterate through the linked list**: Properly delete all nodes in the linked list starting from [`_front`]().
  2. **Correct iteration over [`_NodePtrs`]().
  3. **Use `delete[]` for [`_NodePtrs`]() is an array, use `delete[]` to delete it.

  This ensures that all dynamically allocated memory is properly freed.

Reason:
  Wanted to check the destructor and make sure the smaller functions needed 
  are implemented correctly and quickly so I can move onto the NoveQueue and
  main() and get working on the main portion of the project.
------------------------------------------------------------------------------

Prompt:
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    Queue<DT>* current = _front;
    while (current != nullptr) { //delete all the nodes
      Queue<DT>* tempNext = current->_next;
      delete current;
      current = tempNext;
    }
    delete[] _NodePtrs; //delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }


  double checking, this look good>
Response:
  The destructor implementation looks good overall. It correctly deletes all nodes in the linked list and then deletes the array of node pointers. Here is a quick review and confirmation:

  1. **Deleting Nodes**: The loop correctly iterates through the linked list, deleting each node.
  2. **Deleting Node Pointers Array**: The `delete[] _NodePtrs` statement correctly deletes the array of node pointers.
  3. **Nullifying Pointers**: Setting [`_front`](), [`_rear`](), and [`_NodePtrs`]() to [`nullptr`]() ensures that the pointers are nullified after deletion.

  Here is the code again for confirmation:

  ```cpp
  template <class DT>
  NovelQueue<DT>::~NovelQueue() {
    Queue<DT>* current = _front;
    while (current != nullptr) { // delete all the nodes
      Queue<DT>* tempNext = current->_next;
      delete current;
      current = tempNext;
    }
    delete[] _NodePtrs; // delete pointers to all the nodes
    _front = nullptr;
    _rear = nullptr;
    _NodePtrs = nullptr;
  }
  ```

  ### Summary
  - **Loop through the linked list**: Correctly deletes each node.
  - **Delete the array of node pointers**: Correctly deletes the array.
  - **Nullify pointers**: Ensures pointers are set to [`nullptr`]() after deletion.

  This destructor implementation is correct and should work as intended.

Reason:
  Double checking the way I implemented what was suggested in the previous copilot
  suggesstion.

------------------------------------------------------------------------------

Prompt:

Response:

Reason:

------------------------------------------------------------------------------